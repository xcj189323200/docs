{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{171:function(t,e,a){\"use strict\";a.r(e);var n=a(0),s=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,a=t._self._c||e;return a(\"div\",{staticClass:\"content\"},[a(\"p\",[t._v(\"Vuex 是一个专为 Vue.js 应用程序开发的\"),a(\"strong\",[t._v(\"状态管理模式\")]),t._v(\"。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"vuex-是什么\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vuex-是什么\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" vuex 是什么\")]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"Vuex 是一个专为 Vue.js 应用程序开发的\"),a(\"strong\",[t._v(\"状态管理模式\")]),t._v(\"。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化\")]),t._v(\" \"),a(\"p\",[t._v(\"Vuex 类似 Redux 的状态管理器，用来管理 Vue 的所有组件状态。说白了就是控制应用的一些全局状态。状态改变了，对应的视图也会改变。\")])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"什么是“状态管理模式”？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是“状态管理模式”？\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 什么是“状态管理模式”？\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"new Vue({\\n  // state 模型(model)\\n  data () {\\n    return {\\n      count: 0\\n    }\\n  },\\n  // view 视图(view)\\n  template: `\\n    <div>{{ count }}</div>\\n  `,\\n  // actions 控制器(controller)\\n  methods: {\\n    increment () {\\n      this.count++\\n    }\\n  }\\n})\\n\")])])]),a(\"blockquote\",[a(\"p\",[t._v(\"这个状态自管理应用包含以下几个部分：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"state，驱动应用的数据源\")]),t._v(\" \"),a(\"li\",[t._v(\"view，以声明方式将 state 映射到视图；\")]),t._v(\" \"),a(\"li\",[t._v(\"actions，响应在 view 上的用户输入导致的状态变化。\")])])]),t._v(\" \"),a(\"p\",[t._v(\"以下是一个表示“单向数据流”理念的极简示意：\\n\"),a(\"img\",{attrs:{src:\"http://img.xcj521.cn/17-11-16/72030725.jpg\",alt:\"\"}})]),t._v(\" \"),a(\"h2\",{attrs:{id:\"为什么使用-vuex\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么使用-vuex\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 为什么使用 vuex\")]),t._v(\" \"),a(\"blockquote\",[a(\"ol\",[a(\"li\",[t._v(\"传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力\")]),t._v(\" \"),a(\"li\",[t._v(\"多个视图依赖于同一状态。或者 来自不同视图的行为需要变更同一状态。\")])])]),t._v(\" \"),a(\"h2\",{attrs:{id:\"vuex-流程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vuex-流程\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" VUEX 流程\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"http://img.xcj521.cn/17-11-16/14881158.jpg\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"从上图可以看出\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[t._v(\"在 vue Components 派发了（dispatch) 一个行为 (Actions)\")]),t._v(\" \"),a(\"li\",[t._v(\"在 Actions 中通过 commit 去触发转变 (Mutations )\")]),t._v(\" \"),a(\"li\",[t._v(\"在 Mutations 中去更新 state 最后触发视图的更新\")])]),t._v(\" \"),a(\"h2\",{attrs:{id:\"vuex-核心概念\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vuex-核心概念\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" VUEX 核心概念\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"state\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#state\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" State\")]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"state 定义了应用状态的数据结构，同样可以在这里设置默认的初始状态。\")])]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"export default {\\n    user: {\\n        nickname : '这是一只二哈',\\n        login_name : '',\\n    }\\n}\\n\")])])]),a(\"h3\",{attrs:{id:\"action\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#action\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" Action\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[t._v(\"Action 提交的是 mutation，而不是直接变更状态。\")]),t._v(\" \"),a(\"li\",[t._v(\"Action 可以包含任意异步操作。\")])]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"Actions 即是定义提交触发更改信息的描述，常见的例子有从服务端获取数据，在数据获取完成后会调用 store.commit()来调用更改 Store 中的状态。可以在组件中使用 dispatch 来发出 Actions。\")])]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"export default {\\n  setUser :(context ,data={})=>{\\n    console.log('context =========>',context );\\n    console.log('这是mutations=========>',data);\\n    context.commit('SET_USER',data)\\n  },\\n  setLoginStatus:({commit},data={})=>{\\n      console.log('这是mutations=========>',data);\\n      commit('SET_LOGINSTATUS',data);\\n  }\\n}\\n\")])])]),a(\"h4\",{attrs:{id:\"在组件中分发-action\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在组件中分发-action\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 在组件中分发 Action\")]),t._v(\" \"),a(\"p\",[t._v(\"在 Actions 对象中 对应的键是暴露在外面 可以用\"),a(\"code\",[t._v(\"this.$store.dispatch('xxx')\")]),t._v(\" 触发 或者 在视图中用\"),a(\"code\",[t._v(\"mapActions\")]),t._v(\" 辅助函数将 组件的 method 映射为\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"import { mapActions } from 'vuex'\\n\\nexport default {\\n  // ...\\n  methods: {\\n    ...mapActions([\\n\\t   // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\\n      'increment',\\n\\n      // `mapActions` 也支持载荷：\\n      // 将 `this.incrementBy(amount)` 映射为\\n      // `this.$store.dispatch('incrementBy', amount)`\\n      'incrementBy'\\n    ]),\\n    ...mapActions({\\n    // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\\n      add: 'increment'\\n    })\\n  }\\n}\\n\")])])]),a(\"h4\",{attrs:{id:\"组合-action\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#组合-action\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 组合 Action\")]),t._v(\" \"),a(\"p\",[t._v(\"Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\")]),t._v(\" \"),a(\"p\",[t._v(\"首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"actions: {\\n  actionA ({ commit }) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        commit('someMutation')\\n        resolve()\\n      }, 1000)\\n    })\\n  }\\n}\\n\")])])]),a(\"p\",[t._v(\"现在你可以：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"store.dispatch('actionA').then(() => {\\n  // ...\\n})\\n\")])])]),a(\"p\",[t._v(\"在另外一个 action 中也可以：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"actions: {\\n  // ...\\n  actionB ({ dispatch, commit }) {\\n    return dispatch('actionA').then(() => {\\n      commit('someOtherMutation')\\n    })\\n  }\\n}\\n\")])])]),a(\"p\",[t._v(\"最后，如果我们利用 async / await 这个 JavaScript 即将到来的新特性，我们可以像这样组合 action：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"// 假设 getData() 和 getOtherData() 返回的是 Promise\\n\\nactions: {\\n  async actionA ({ commit }) {\\n    commit('gotData', await getData())\\n  },\\n  async actionB ({ dispatch, commit }) {\\n    await dispatch('actionA') // 等待 actionA 完成\\n    commit('gotOtherData', await getOtherData())\\n  }\\n}\\n\")])])]),a(\"h3\",{attrs:{id:\"mutation\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mutation\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" Mutation\")]),t._v(\" \"),a(\"blockquote\",[a(\"ul\",[a(\"li\",[t._v(\"mutations: 调用 mutations 是唯一允许更新应用状态的地方。\")]),t._v(\" \"),a(\"li\",[t._v(\"Mutation 必须是同步函数\")])]),t._v(\" \"),a(\"p\",[t._v(\"更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：\")])]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"const store = new Vuex.Store({\\n  state: {\\n    count: 1\\n  },\\n  mutations: {\\n    increment (state) {\\n      // 变更状态\\n      state.count++\\n    }\\n  }\\n})\\n\")])])]),a(\"p\",[t._v(\"你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"store.commit('increment',data)\\n\")])])]),a(\"h4\",{attrs:{id:\"mutation-需遵守-vue-的响应规则\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mutation-需遵守-vue-的响应规则\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" Mutation 需遵守 Vue 的响应规则\")]),t._v(\" \"),a(\"p\",[t._v(\"既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[t._v(\"最好提前在你的 store 中初始化好所有所需属性。\")]),t._v(\" \"),a(\"li\",[t._v(\"当需要在对象上添加新属性时，你应该\")])]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"使用 \"),a(\"code\",[t._v(\"Vue.set(obj, 'newProp', 123)\")]),t._v(\", 或者\")]),t._v(\" \"),a(\"li\",[t._v(\"以新对象替换老对象。例如，利用对象展开运算符我们可以这样写：\\n\"),a(\"code\",[t._v(\"state.obj = { ...state.obj, newProp: 123 }\")])])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"getter\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#getter\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" Getter\")]),t._v(\" \"),a(\"p\",[t._v(\"有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"computed: {\\n  doneTodosCount () {\\n    return this.$store.state.todos.filter(todo => todo.done).length\\n  }\\n}\\n\")])])]),a(\"p\",[t._v(\"如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。\")]),t._v(\" \"),a(\"p\",[t._v(\"Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\")]),t._v(\" \"),a(\"p\",[t._v(\"Getter 接受 state 作为其第一个参数：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"const store = new Vuex.Store({\\n  state: {\\n    todos: [\\n      { id: 1, text: '...', done: true },\\n      { id: 2, text: '...', done: false }\\n    ]\\n  },\\n  getters: {\\n    doneTodos: state => {\\n      return state.todos.filter(todo => todo.done)\\n    }\\n  }\\n})\\n\")])])]),a(\"p\",[t._v(\"Getter 会暴露为 store.getters 对象：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"store.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]\\n\")])])]),a(\"p\",[t._v(\"Getter 也可以接受其他 getter 作为第二个参数：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"getters: {\\n  // ...\\n  doneTodosCount: (state, getters) => {\\n    return getters.doneTodos.length\\n  }\\n}\\nstore.getters.doneTodosCount // -> 1\\n\")])])]),a(\"p\",[t._v(\"我们可以很容易地在任何组件中使用它：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"computed: {\\n  doneTodosCount () {\\n    return this.$store.getters.doneTodosCount\\n  }\\n}\\n\")])])]),a(\"h4\",{attrs:{id:\"mapgetters-辅助函数\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mapgetters-辅助函数\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" mapGetters 辅助函数\")]),t._v(\" \"),a(\"p\",[a(\"code\",[t._v(\"mapGetters\")]),t._v(\" 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"import { mapGetters } from 'vuex'\\n\\nexport default {\\n  // ...\\n  computed: {\\n  // 使用对象展开运算符将 getter 混入 computed 对象中\\n    ...mapGetters([\\n      'doneTodosCount',\\n      'anotherGetter',\\n      // ...\\n    ])\\n  }\\n}\\n\")])])]),a(\"p\",[t._v(\"如果你想将一个 getter 属性另取一个名字，使用对象形式：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"mapGetters({\\n  // 映射 `this.doneCount` 为 `store.getters.doneTodosCount`\\n  doneCount: 'doneTodosCount'\\n})\\n\")])])]),a(\"h2\",{attrs:{id:\"插件\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#插件\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 插件\")]),t._v(\" \"),a(\"p\",[t._v(\"Vuex 的 store 接受 plugins 选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 store 作为唯一参数：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"const myPlugin = store => {\\n  // 当 store 初始化后调用\\n  store.subscribe((mutation, state) => {\\n    // 每次 mutation 之后调用\\n    // mutation 的格式为 { type, payload }\\n  })\\n}\\n\")])])]),a(\"p\",[t._v(\"然后像这样使用：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"const store = new Vuex.Store({\\n  // ...\\n  plugins: [myPlugin]\\n})\\n\")])])]),a(\"h3\",{attrs:{id:\"在插件内提交-mutation\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在插件内提交-mutation\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 在插件内提交 Mutation\")]),t._v(\" \"),a(\"p\",[t._v(\"在插件中不允许直接修改状态——类似于组件，只能通过提交 mutation 来触发变化。\")]),t._v(\" \"),a(\"p\",[t._v(\"通过提交 mutation，插件可以用来同步数据源到 store。例如，同步 websocket 数据源到 store（下面是个大概例子，实际上 createPlugin 方法可以有更多选项来完成复杂任务）：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"export default function createWebSocketPlugin (socket) {\\n  return store => {\\n    socket.on('data', data => {\\n      store.commit('receiveData', data)\\n    })\\n    store.subscribe(mutation => {\\n      if (mutation.type === 'UPDATE_DATA') {\\n        socket.emit('update', mutation.payload)\\n      }\\n    })\\n  }\\n}\\nconst plugin = createWebSocketPlugin(socket)\\n\\nconst store = new Vuex.Store({\\n  state,\\n  mutations,\\n  plugins: [plugin]\\n})\\n\")])])]),a(\"h3\",{attrs:{id:\"内置-logger-插件\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#内置-logger-插件\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 内置 Logger 插件\")]),t._v(\" \"),a(\"p\",[t._v(\"Vuex 自带一个日志插件用于一般的调试:\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"import createLogger from 'vuex/dist/logger'\\n\\nconst store = new Vuex.Store({\\n  plugins: [createLogger()]\\n})\\n\")])])]),a(\"p\",[t._v(\"createLogger 函数有几个配置项：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('const logger = createLogger({\\n  collapsed: false, // 自动展开记录的 mutation\\n  filter (mutation, stateBefore, stateAfter) {\\n    // 若 mutation 需要被记录，就让它返回 true 即可\\n    // 顺便，`mutation` 是个 { type, payload } 对象\\n    return mutation.type !== \"aBlacklistedMutation\"\\n  },\\n  transformer (state) {\\n    // 在开始记录之前转换状态\\n    // 例如，只返回指定的子树\\n    return state.subTree\\n  },\\n  mutationTransformer (mutation) {\\n    // mutation 按照 { type, payload } 格式记录\\n    // 我们可以按任意方式格式化\\n    return mutation.type\\n  },\\n  logger: console, // 自定义 console 实现，默认为 `console`\\n})\\n')])])])])}],!1,null,null,null);e.default=s.exports}}]);","extractedComments":[]}