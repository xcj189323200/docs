{"remainingRequest":"/Users/xuchangjian/workspace/my/pc/docs/node_modules/_vue-loader@15.7.0@vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/xuchangjian/workspace/my/pc/docs/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js??ref--1-0!/Users/xuchangjian/workspace/my/pc/docs/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js??ref--1-1!/Users/xuchangjian/workspace/my/pc/docs/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/xuchangjian/workspace/my/pc/docs/src/web/vuex.md?vue&type=template&id=2b3b8f20&","dependencies":[{"path":"/Users/xuchangjian/workspace/my/pc/docs/src/web/vuex.md","mtime":1559207856025},{"path":"/Users/xuchangjian/workspace/my/pc/docs/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/xuchangjian/workspace/my/pc/docs/node_modules/_vue-loader@15.7.0@vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/xuchangjian/workspace/my/pc/docs/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/xuchangjian/workspace/my/pc/docs/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/xuchangjian/workspace/my/pc/docs/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化</p> <h2 id=\\\"vuex-是什么\\\"><a href=\\\"#vuex-是什么\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> vuex 是什么</h2> <blockquote><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化</p> <p>Vuex 类似 Redux 的状态管理器，用来管理 Vue 的所有组件状态。说白了就是控制应用的一些全局状态。状态改变了，对应的视图也会改变。</p></blockquote> <h3 id=\\\"什么是“状态管理模式”？\\\"><a href=\\\"#什么是“状态管理模式”？\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 什么是“状态管理模式”？</h3> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>new Vue({\\n  // state 模型(model)\\n  data () {\\n    return {\\n      count: 0\\n    }\\n  },\\n  // view 视图(view)\\n  template: `\\n    &lt;div&gt;{{ count }}&lt;/div&gt;\\n  `,\\n  // actions 控制器(controller)\\n  methods: {\\n    increment () {\\n      this.count++\\n    }\\n  }\\n})\\n</code></pre></div><blockquote><p>这个状态自管理应用包含以下几个部分：</p> <ul><li>state，驱动应用的数据源</li> <li>view，以声明方式将 state 映射到视图；</li> <li>actions，响应在 view 上的用户输入导致的状态变化。</li></ul></blockquote> <p>以下是一个表示“单向数据流”理念的极简示意：\\n<img src=\\\"http://img.xcj521.cn/17-11-16/72030725.jpg\\\" alt></p> <h2 id=\\\"为什么使用-vuex\\\"><a href=\\\"#为什么使用-vuex\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 为什么使用 vuex</h2> <blockquote><ol><li>传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力</li> <li>多个视图依赖于同一状态。或者 来自不同视图的行为需要变更同一状态。</li></ol></blockquote> <h2 id=\\\"vuex-流程\\\"><a href=\\\"#vuex-流程\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> VUEX 流程</h2> <p><img src=\\\"http://img.xcj521.cn/17-11-16/14881158.jpg\\\" alt></p> <p>从上图可以看出</p> <ol><li>在 vue Components 派发了（dispatch) 一个行为 (Actions)</li> <li>在 Actions 中通过 commit 去触发转变 (Mutations )</li> <li>在 Mutations 中去更新 state 最后触发视图的更新</li></ol> <h2 id=\\\"vuex-核心概念\\\"><a href=\\\"#vuex-核心概念\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> VUEX 核心概念</h2> <h3 id=\\\"state\\\"><a href=\\\"#state\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> State</h3> <blockquote><p>state 定义了应用状态的数据结构，同样可以在这里设置默认的初始状态。</p></blockquote> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>export default {\\n    user: {\\n        nickname : '这是一只二哈',\\n        login_name : '',\\n    }\\n}\\n</code></pre></div><h3 id=\\\"action\\\"><a href=\\\"#action\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Action</h3> <ol><li>Action 提交的是 mutation，而不是直接变更状态。</li> <li>Action 可以包含任意异步操作。</li></ol> <blockquote><p>Actions 即是定义提交触发更改信息的描述，常见的例子有从服务端获取数据，在数据获取完成后会调用 store.commit()来调用更改 Store 中的状态。可以在组件中使用 dispatch 来发出 Actions。</p></blockquote> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>export default {\\n  setUser :(context ,data={})=&gt;{\\n    console.log('context =========&gt;',context );\\n    console.log('这是mutations=========&gt;',data);\\n    context.commit('SET_USER',data)\\n  },\\n  setLoginStatus:({commit},data={})=&gt;{\\n      console.log('这是mutations=========&gt;',data);\\n      commit('SET_LOGINSTATUS',data);\\n  }\\n}\\n</code></pre></div><h4 id=\\\"在组件中分发-action\\\"><a href=\\\"#在组件中分发-action\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 在组件中分发 Action</h4> <p>在 Actions 对象中 对应的键是暴露在外面 可以用<code>this.$store.dispatch('xxx')</code> 触发 或者 在视图中用<code>mapActions</code> 辅助函数将 组件的 method 映射为</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>import { mapActions } from 'vuex'\\n\\nexport default {\\n  // ...\\n  methods: {\\n    ...mapActions([\\n\\t   // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\\n      'increment',\\n\\n      // `mapActions` 也支持载荷：\\n      // 将 `this.incrementBy(amount)` 映射为\\n      // `this.$store.dispatch('incrementBy', amount)`\\n      'incrementBy'\\n    ]),\\n    ...mapActions({\\n    // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\\n      add: 'increment'\\n    })\\n  }\\n}\\n</code></pre></div><h4 id=\\\"组合-action\\\"><a href=\\\"#组合-action\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 组合 Action</h4> <p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p> <p>首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>actions: {\\n  actionA ({ commit }) {\\n    return new Promise((resolve, reject) =&gt; {\\n      setTimeout(() =&gt; {\\n        commit('someMutation')\\n        resolve()\\n      }, 1000)\\n    })\\n  }\\n}\\n</code></pre></div><p>现在你可以：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>store.dispatch('actionA').then(() =&gt; {\\n  // ...\\n})\\n</code></pre></div><p>在另外一个 action 中也可以：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>actions: {\\n  // ...\\n  actionB ({ dispatch, commit }) {\\n    return dispatch('actionA').then(() =&gt; {\\n      commit('someOtherMutation')\\n    })\\n  }\\n}\\n</code></pre></div><p>最后，如果我们利用 async / await 这个 JavaScript 即将到来的新特性，我们可以像这样组合 action：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>// 假设 getData() 和 getOtherData() 返回的是 Promise\\n\\nactions: {\\n  async actionA ({ commit }) {\\n    commit('gotData', await getData())\\n  },\\n  async actionB ({ dispatch, commit }) {\\n    await dispatch('actionA') // 等待 actionA 完成\\n    commit('gotOtherData', await getOtherData())\\n  }\\n}\\n</code></pre></div><h3 id=\\\"mutation\\\"><a href=\\\"#mutation\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Mutation</h3> <blockquote><ul><li>mutations: 调用 mutations 是唯一允许更新应用状态的地方。</li> <li>Mutation 必须是同步函数</li></ul> <p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p></blockquote> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const store = new Vuex.Store({\\n  state: {\\n    count: 1\\n  },\\n  mutations: {\\n    increment (state) {\\n      // 变更状态\\n      state.count++\\n    }\\n  }\\n})\\n</code></pre></div><p>你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>store.commit('increment',data)\\n</code></pre></div><h4 id=\\\"mutation-需遵守-vue-的响应规则\\\"><a href=\\\"#mutation-需遵守-vue-的响应规则\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Mutation 需遵守 Vue 的响应规则</h4> <p>既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p> <ol><li>最好提前在你的 store 中初始化好所有所需属性。</li> <li>当需要在对象上添加新属性时，你应该</li></ol> <ul><li>使用 <code>Vue.set(obj, 'newProp', 123)</code>, 或者</li> <li>以新对象替换老对象。例如，利用对象展开运算符我们可以这样写：\\n<code>state.obj = { ...state.obj, newProp: 123 }</code></li></ul> <h3 id=\\\"getter\\\"><a href=\\\"#getter\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Getter</h3> <p>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>computed: {\\n  doneTodosCount () {\\n    return this.$store.state.todos.filter(todo =&gt; todo.done).length\\n  }\\n}\\n</code></pre></div><p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。</p> <p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p> <p>Getter 接受 state 作为其第一个参数：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const store = new Vuex.Store({\\n  state: {\\n    todos: [\\n      { id: 1, text: '...', done: true },\\n      { id: 2, text: '...', done: false }\\n    ]\\n  },\\n  getters: {\\n    doneTodos: state =&gt; {\\n      return state.todos.filter(todo =&gt; todo.done)\\n    }\\n  }\\n})\\n</code></pre></div><p>Getter 会暴露为 store.getters 对象：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>store.getters.doneTodos // -&gt; [{ id: 1, text: '...', done: true }]\\n</code></pre></div><p>Getter 也可以接受其他 getter 作为第二个参数：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>getters: {\\n  // ...\\n  doneTodosCount: (state, getters) =&gt; {\\n    return getters.doneTodos.length\\n  }\\n}\\nstore.getters.doneTodosCount // -&gt; 1\\n</code></pre></div><p>我们可以很容易地在任何组件中使用它：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>computed: {\\n  doneTodosCount () {\\n    return this.$store.getters.doneTodosCount\\n  }\\n}\\n</code></pre></div><h4 id=\\\"mapgetters-辅助函数\\\"><a href=\\\"#mapgetters-辅助函数\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> mapGetters 辅助函数</h4> <p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>import { mapGetters } from 'vuex'\\n\\nexport default {\\n  // ...\\n  computed: {\\n  // 使用对象展开运算符将 getter 混入 computed 对象中\\n    ...mapGetters([\\n      'doneTodosCount',\\n      'anotherGetter',\\n      // ...\\n    ])\\n  }\\n}\\n</code></pre></div><p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>mapGetters({\\n  // 映射 `this.doneCount` 为 `store.getters.doneTodosCount`\\n  doneCount: 'doneTodosCount'\\n})\\n</code></pre></div><h2 id=\\\"插件\\\"><a href=\\\"#插件\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 插件</h2> <p>Vuex 的 store 接受 plugins 选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 store 作为唯一参数：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const myPlugin = store =&gt; {\\n  // 当 store 初始化后调用\\n  store.subscribe((mutation, state) =&gt; {\\n    // 每次 mutation 之后调用\\n    // mutation 的格式为 { type, payload }\\n  })\\n}\\n</code></pre></div><p>然后像这样使用：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const store = new Vuex.Store({\\n  // ...\\n  plugins: [myPlugin]\\n})\\n</code></pre></div><h3 id=\\\"在插件内提交-mutation\\\"><a href=\\\"#在插件内提交-mutation\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 在插件内提交 Mutation</h3> <p>在插件中不允许直接修改状态——类似于组件，只能通过提交 mutation 来触发变化。</p> <p>通过提交 mutation，插件可以用来同步数据源到 store。例如，同步 websocket 数据源到 store（下面是个大概例子，实际上 createPlugin 方法可以有更多选项来完成复杂任务）：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>export default function createWebSocketPlugin (socket) {\\n  return store =&gt; {\\n    socket.on('data', data =&gt; {\\n      store.commit('receiveData', data)\\n    })\\n    store.subscribe(mutation =&gt; {\\n      if (mutation.type === 'UPDATE_DATA') {\\n        socket.emit('update', mutation.payload)\\n      }\\n    })\\n  }\\n}\\nconst plugin = createWebSocketPlugin(socket)\\n\\nconst store = new Vuex.Store({\\n  state,\\n  mutations,\\n  plugins: [plugin]\\n})\\n</code></pre></div><h3 id=\\\"内置-logger-插件\\\"><a href=\\\"#内置-logger-插件\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 内置 Logger 插件</h3> <p>Vuex 自带一个日志插件用于一般的调试:</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>import createLogger from 'vuex/dist/logger'\\n\\nconst store = new Vuex.Store({\\n  plugins: [createLogger()]\\n})\\n</code></pre></div><p>createLogger 函数有几个配置项：</p> <div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const logger = createLogger({\\n  collapsed: false, // 自动展开记录的 mutation\\n  filter (mutation, stateBefore, stateAfter) {\\n    // 若 mutation 需要被记录，就让它返回 true 即可\\n    // 顺便，`mutation` 是个 { type, payload } 对象\\n    return mutation.type !== &quot;aBlacklistedMutation&quot;\\n  },\\n  transformer (state) {\\n    // 在开始记录之前转换状态\\n    // 例如，只返回指定的子树\\n    return state.subTree\\n  },\\n  mutationTransformer (mutation) {\\n    // mutation 按照 { type, payload } 格式记录\\n    // 我们可以按任意方式格式化\\n    return mutation.type\\n  },\\n  logger: console, // 自定义 console 实现，默认为 `console`\\n})\\n</code></pre></div>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}