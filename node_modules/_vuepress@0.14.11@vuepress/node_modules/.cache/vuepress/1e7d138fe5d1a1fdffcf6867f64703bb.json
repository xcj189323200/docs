{"remainingRequest":"/Users/xuchangjian/workspace/my/pc/docs/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js??ref--1-1!/Users/xuchangjian/workspace/my/pc/docs/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/xuchangjian/workspace/my/pc/docs/src/web/express.md?vue&type=template&id=6b959871&","dependencies":[{"path":"/Users/xuchangjian/workspace/my/pc/docs/src/web/express.md","mtime":1559207825408},{"path":"/Users/xuchangjian/workspace/my/pc/docs/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/xuchangjian/workspace/my/pc/docs/node_modules/_vue-loader@15.7.0@vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/xuchangjian/workspace/my/pc/docs/node_modules/_cache-loader@1.2.5@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/xuchangjian/workspace/my/pc/docs/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/xuchangjian/workspace/my/pc/docs/node_modules/_vuepress@0.14.11@vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"express\">express</h1>\n<h2 id=\"express-是什么\">express 是什么</h2>\n<p>Express是目前最流行的基于Node.js的Web开发框架，可以快速地搭建一个完整功能的网站。</p>\n<h2 id=\"express-中间件\">express 中间件</h2>\n<p>中间件（middleware）就是处理HTTP请求的函数。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。App实例在运行过程中，会调用一系列的中间件。</p>\n<p>每个中间件可以从App实例，接收三个参数，依次为request对象（代表HTTP请求）、response对象（代表HTTP回应），next回调函数（代表下一个中间件）。每个中间件都可以对HTTP请求（request对象）进行加工，并且决定是否调用next方法，将request对象再传给下一个中间件。</p>\n<p>一个不进行任何操作、只传递request对象的中间件，就是下面这样。</p>\n<pre><code>function uselessMiddleware(req, res, next) {\n      next();\n}\n</code></pre>\n<p>上面代码的next就是下一个中间件。如果它带有参数，则代表抛出一个错误，参数为错误文本。</p>\n<pre><code>function uselessMiddleware(req, res, next) {\n  next('出错了！');\n}\n</code></pre>\n<h2 id=\"express-运行原理\">express 运行原理</h2>\n<p>Express框架建立在node.js内置的http模块上。http模块生成服务器的原始代码如下。</p>\n<pre><code>var http = require(&quot;http&quot;);\n\nvar app = http.createServer(function(request, response) {\n  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});\n  response.end(&quot;Hello world!&quot;);\n});\n\napp.listen(3000, &quot;localhost&quot;);\n</code></pre>\n<p>上面代码的关键是http模块的createServer方法，表示生成一个HTTP服务器实例。该方法接受一个回调函数，该回调函数的参数，分别为代表HTTP请求和HTTP回应的request对象和response对象。</p>\n<p>Express框架的核心是对http模块的再包装。上面的代码用Express改写如下。</p>\n<pre><code>var express = require('express');\nvar app = express();\n\napp.get('/', function (req, res) {\n  res.send('Hello world!');\n});\n\napp.listen(3000);\n</code></pre>\n<p>比较两段代码，可以看到它们非常接近。原来是用http.createServer方法新建一个app实例，现在则是用Express的构造方法，生成一个Epress实例。两者的回调函数都是相同的。Express框架等于在http模块之上，加了一个中间层。</p>\n<hr>\n<h1 id=\"express-准备工作\">express 准备工作</h1>\n<p>利用express 自带的生成器初始化项目\nnpm install express-generator -g</p>\n<blockquote>\n<p>express-generator是Express4自带的命令行工具，用来初始化Express项目，所以只需要将其全局安装，而不需要将整个Express全局安装，这和Express3不同，在Express3中，命令行集成在整个Express项目中，所以必须将Express3全局安装。</p>\n</blockquote>\n<p>使用express命令初始化项目</p>\n<pre><code>express --git -f\n</code></pre>\n<p>express命令有一些可选参数，具体可以参看官方文档。这里我们只用到了两个。</p>\n<blockquote>\n<p>–git ：告知express生成.gitignore文件，这个文件定义了git需要忽略控制的文件，通常node_mondules会被写到此文件里。</p>\n</blockquote>\n<blockquote>\n<p>-f ：当目标文件夹不为空时，仍然强制执行。这里加此选项的原因是因为我们clone下来的项目里原本含有LICENSE 和 README.md两个文件。</p>\n</blockquote>\n<p>然后 <code>npm install</code> 安装依赖即可</p>\n<p>启动这个应用（MacOS 或 Linux 平台）：</p>\n<pre><code>DEBUG=myapp npm start\n</code></pre>\n<p>Windows 平台使用如下命令：</p>\n<pre><code>set DEBUG=myapp &amp; npm start\n</code></pre>\n<p>然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了。</p>\n<hr>\n<h1 id=\"express-的方法\">Express 的方法</h1>\n<h2 id=\"use-方法\">use() 方法</h2>\n<p>use是express注册中间件的方法，它返回一个函数。下面是一个连续调用两个中间件的例子。</p>\n<pre><code>var express = require(&quot;express&quot;);\nvar http = require(&quot;http&quot;);\n\nvar app = express();\n\napp.use(function(request, response, next) {\n  console.log(&quot;In comes a &quot; + request.method + &quot; to &quot; + request.url);\n  next();\n});\n\napp.use(function(request, response) {\n  response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });\n  response.end(&quot;Hello world!\\n&quot;);\n});\n\nhttp.createServer(app).listen(1337);\n</code></pre>\n<p>上面代码使用app.use方法，注册了两个中间件。收到HTTP请求后，先调用第一个中间件，在控制台输出一行信息，然后通过next方法，将执行权传给第二个中间件，输出HTTP回应。由于第二个中间件没有调用next方法，所以request对象就不再向后传递了。</p>\n<p>use方法内部可以对访问路径进行判断，据此就能实现简单的路由，根据不同的请求网址，返回不同的网页内容。</p>\n<pre><code>var express = require(&quot;express&quot;);\nvar http = require(&quot;http&quot;);\n\nvar app = express();\n\napp.use(function(request, response, next) {\n  if (request.url == &quot;/&quot;) {\n    response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });\n    response.end(&quot;Welcome to the homepage!\\n&quot;);\n  } else {\n    next();\n  }\n});\n\napp.use(function(request, response, next) {\n  if (request.url == &quot;/about&quot;) {\n    response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });\n  } else {\n    next();\n  }\n});\n\napp.use(function(request, response) {\n  response.writeHead(404, { &quot;Content-Type&quot;: &quot;text/plain&quot; });\n  response.end(&quot;404 error!\\n&quot;);\n});\n\nhttp.createServer(app).listen(1337);\n</code></pre>\n<p>上面代码通过request.url属性，判断请求的网址，从而返回不同的内容。注意，app.use方法一共登记了三个中间件，只要请求路径匹配，就不会将执行权交给下一个中间件。因此，最后一个中间件会返回404错误，即前面的中间件都没匹配请求路径，找不到所要请求的资源。</p>\n<p>除了在回调函数内部判断请求的网址，use方法也允许将请求网址写在第一个参数。这代表，只有请求路径匹配这个参数，后面的中间件才会生效。无疑，这样写更加清晰和方便。</p>\n<pre><code>app.use('/path', someMiddleware);\n</code></pre>\n<h2 id=\"all方法和http动词方法\">all方法和HTTP动词方法</h2>\n<p>针对不同的请求，Express提供了use方法的一些别名。比如，上面代码也可以用别名的形式来写。</p>\n<pre><code>var express = require(&quot;express&quot;);\nvar http = require(&quot;http&quot;);\nvar app = express();\n\napp.all(&quot;*&quot;, function(request, response, next) {\n  response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });\n  next();\n});\n\napp.get(&quot;/&quot;, function(request, response) {\n  response.end(&quot;Welcome to the homepage!&quot;);\n});\n\napp.get(&quot;/about&quot;, function(request, response) {\n  response.end(&quot;Welcome to the about page!&quot;);\n});\n\napp.get(&quot;*&quot;, function(request, response) {\n  response.end(&quot;404!&quot;);\n});\n\nhttp.createServer(app).listen(1337);\n</code></pre>\n<p>上面代码的all方法表示，所有请求都必须通过该中间件，参数中的“*”表示对所有路径有效。get方法则是只有GET动词的HTTP请求通过该中间件，它的第一个参数是请求的路径。由于get方法的回调函数没有调用next方法，所以只要有一个中间件被调用了，后面的中间件就不会再被调用了。</p>\n<p>除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法。</p>\n<p>这些方法的第一个参数，都是请求的路径。除了绝对匹配以外，Express允许模式匹配。</p>\n<blockquote>\n<p>注意：app.all() 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。</p>\n</blockquote>\n<pre><code> app.all('/secret', function (req, res, next) {\n  console.log('Accessing the secret section ...');\n  next(); // pass control to the next handler\n});\n</code></pre>\n<h3 id=\"set方法\">set方法</h3>\n<p>set方法用于指定变量的值。</p>\n<pre><code>app.set(&quot;views&quot;, __dirname + &quot;/views&quot;);\n\napp.set(&quot;view engine&quot;, &quot;jade&quot;);\n</code></pre>\n<p>上面代码使用set方法，为系统变量“views”和“view engine”指定值。</p>\n<h3 id=\"response对象\">response对象</h3>\n<h4 id=\"_1-response-redirect方法\">1.  response.redirect方法:</h4>\n<blockquote>\n<p>response.redirect方法允许网址的重定向。</p>\n</blockquote>\n<pre><code>response.redirect(&quot;/hello/anime&quot;);\nresponse.redirect(&quot;http://www.example.com&quot;);\nresponse.redirect(301, &quot;http://www.example.com&quot;);\n</code></pre>\n<h4 id=\"_2-response-sendfile方法\">2.  response.sendFile方法:</h4>\n<blockquote>\n<p>response.sendFile方法用于发送文件。以八位字节流的形式发送文件。</p>\n</blockquote>\n<pre><code>response.sendFile(&quot;/path/to/anime.mp4&quot;);\n</code></pre>\n<h4 id=\"_3-response-render方法\">3.  response.render方法:</h4>\n<blockquote>\n<p>response.render方法用于渲染网页模板。</p>\n</blockquote>\n<pre><code>app.get(&quot;/&quot;, function(request, response) {\n  response.render(&quot;index&quot;, { message: &quot;Hello World&quot; });\n});\n//上面代码使用render方法，将message变量传入index模板，渲染成HTML网页。\n</code></pre>\n<h4 id=\"_4-response-render方法\">4.  response.render方法:</h4>\n<blockquote>\n<p>response.render方法用于渲染网页模板。下面代码使用render方法，将message变量传入index模板，渲染成HTML网页。</p>\n</blockquote>\n<pre><code>app.get(&quot;/&quot;, function(request, response) {\n  response.render(&quot;index&quot;, { message: &quot;Hello World&quot; });\n});\n</code></pre>\n<h4 id=\"_5-res-json方法\">5. res.json方法:</h4>\n<blockquote>\n<p>发送一个 JSON 格式的响应。</p>\n</blockquote>\n<h4 id=\"_6-res-end方法\">6.res.end方法:</h4>\n<blockquote>\n<p>终结响应处理流程。</p>\n</blockquote>\n<h4 id=\"_7-res-sendstatus方法\">7.res.sendStatus方法:</h4>\n<blockquote>\n<p>设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。</p>\n</blockquote>\n<pre><code>res.sendStatus(200); // equivalent to res.status(200).send('OK')\nres.sendStatus(403); // equivalent to res.status(403).send('Forbidden')\nres.sendStatus(404); // equivalent to res.status(404).send('Not Found')\nres.sendStatus(500); // equivalent to res.status(500).send('Internal ServerError')\n</code></pre>\n<h4 id=\"_8-res-cookie-name-value-options-方法\">8.res.cookie(name, value [, options])方法:</h4>\n<h5 id=\"cookie的创建\">cookie的创建:</h5>\n<p>express直接提供了api,只需要在需要使用的地方调用如下api即可</p>\n<pre><code>   function(req, res, next){\n        ...\n        res.cookie(name, value [, options]);\n        ...\n    }\n</code></pre>\n<p>express就会将其填入Response Header中的Set-Cookie，达到在浏览器中设置cookie的作用。</p>\n<ul>\n<li>name: 类型为String</li>\n<li>value: 类型为String和Object，如果是Object会自动调用JSON.stringify对其进行处理</li>\n<li>Option: 类型为对象，可使用的属性如下：</li>\n</ul>\n<blockquote>\n<p>domain：cookie在什么域名下有效，类型为String,。默认为网站域名\nexpires: cookie过期时间，类型为Date。如果没有设置或者设置为0，那么该cookie只在这个这个session有效，即关闭浏览器后，这个cookie会被浏览器删除。\nhttpOnly: 只能被web server访问，类型Boolean。\nmaxAge: 实现expires的功能，设置cookie过期的时间，类型为String，指明从现在开始，多少毫秒以后，cookie到期。\npath: cookie在什么路径下有效，默认为'/'，类型为String\nsecure：只能被HTTPS使用，类型Boolean，默认为false\nsigned:使用签名，类型Boolean，默认为false。<code>express会使用req.secret来完成签名，需要cookie-parser配合使用</code></p>\n</blockquote>\n<pre><code>res.cookie('name', 'koby', { domain: '.example.com', path: '/admin', secure: true });\n//cookie的有效期为900000ms\nres.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n//cookie的有效期为900000ms\nres.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true });\n\n//cookie的value为对象\nres.cookie('cart', { items: [1,2,3] });\nres.cookie('cart', { items: [1,2,3] }, { maxAge: 900000 });\n\nres.cookie('name', 'tobi', { signed: true });\n</code></pre>\n<h5 id=\"cookie的删除\">cookie的删除</h5>\n<p>express直接提供了api删除浏览器中的cookie,只需要在需要使用的地方调用如下api即可</p>\n<pre><code>function(req, res, next){\n    ...\n    res.clearCookie(name [, options]);\n    ...\n}\n</code></pre>\n<p>利用cookie-parser读取cookie</p>\n<pre><code>    npm install cookie-parser --save\n</code></pre>\n<blockquote>\n<p>cookie-parser是一个非常好用方便的插件，可以直接用在express和connect中，官文地址为https://www.npmjs.com/package/cookie-parser。npm安装命令</p>\n</blockquote>\n<pre><code>var express = require('express');\nvar cookieParser = require('cookie-parser');\n\nvar app = express();\n//不使用签名\napp.use(cookieParser());  //挂载中间件，可以理解为实例化\n\n//若需要使用签名，需要指定一个secret,字符串,否者会报错\napp.use(cookieParser('Simon'));\n</code></pre>\n<p>获取cookie(无签名)</p>\n<blockquote>\n<p>var cookies = req.cookies      # 获取cookie集合\nvar value = req.cookies.key    # 获取名称为key的cookie的值</p>\n</blockquote>\n<p>获取cookie(有签名)</p>\n<blockquote>\n<p>var cookies = req.signedCookies      # 获取cookie集合\nvar value = req.signedCookies.key    # 获取名称为key的cookie的值</p>\n</blockquote>\n<p>exmple:</p>\n<pre><code>var express = require('express');\nvar app = express();\nvar cookieParser = require('cookie-parser');\n\n//不使用签名\n// app.use(cookieParser());  //挂载中间件，可以理解为实例化\n\n//若需要使用签名，需要指定一个secret,字符串,否者会报错\napp.use(cookieParser('simon'));\n\n// 设置cookie\napp.get('/setCookie', function (req, res, next) {\n    req.secret = 'simon'; //签名不能做到加密 只能做到防止篡改\n    res.cookie('name', 'iwen');\n    res.cookie('signed1', 'signed2', {signed: true});\n    res.cookie('rememberme', '1', {expires: new Date(Date.now() + 900000), httpOnly: true});\n    res.cookie('cart', {items: [1, 2, 3]}, {maxAge: 900000});\n\n    console.log(&quot;无签名的&quot;,req.cookies);\n    console.log(&quot;有签名的&quot;,req.signedCookies);\n    res.send('设置成功')\n});\n\n\napp.listen(3333, function () {\n    console.log('执行了')\n});\n</code></pre>\n<h4 id=\"_9-res-session方法\">9.res.session方法:</h4>\n<pre><code> npm install cookie-session\n</code></pre>\n<p>cookieSession之前需要使用cookieParser中间件</p>\n<pre><code>var express =require('express');\nvar app = express();\napp.use(express.cookieParser('S3CRE7'));\napp.use(express.cookieSession(opt));\n</code></pre>\n<p>中间件传递参数如下：</p>\n<blockquote>\n<p>key : cookie键，session_id；\nsecret : 加密cookie值的字符串，与cookieParser中的secret功能完全相同，如果cookieParser没有传入secret参数，此处必须传入。个人角度为了主观上的感觉，采用了两个不同的值。\ncookie ： 设置cookie的相关参数，即除KV对之外的expire/maxAge,httpOnly,path值\nproxy ： 是否信任反向代理，默认false</p>\n</blockquote>\n<p>example:</p>\n<pre><code>var express = require('express');\nvar app = express();\nvar cookieParser = require('cookie-parser');\nconst cookieSession = require('cookie-session');\n\n/* 使用session */\nvar session_arr = [];\nfor (var i = 0; i &lt; 100000; i++) {\n    session_arr.push('keys_' + Math.random());\n}\napp.use(cookieParser());\napp.use(cookieSession({name: 'api_session_id', keys: session_arr}));\n\n// 设置cookie\napp.get('/setSession', function (req, res, next) {\n    if (!req.session['count']) {\n        req.session['count'] = 1;\n    } else {\n        req.session['count']++;\n    }\n\n    console.log(&quot;访问次数&quot;, req.session['count']);\n    res.send('设置成功')\n});\n\n\napp.listen(3333, function () {\n    console.log('执行了')\n});\n</code></pre>\n<h3 id=\"requst对象\">requst对象</h3>\n<h4 id=\"request-ip\">request.ip</h4>\n<blockquote>\n<p>request.ip属性用于获得HTTP请求的IP地址。</p>\n</blockquote>\n<h4 id=\"request-files\">request.files</h4>\n<blockquote>\n<p>request.files用于获取上传的文件。</p>\n</blockquote>\n<h4 id=\"req-body\">req.body</h4>\n<pre><code>npm install body-parse --save\n</code></pre>\n<blockquote>\n<ol>\n<li>bodyParser.json(options): 解析json数据</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>bodyParser.raw(options): 解析二进制格式(Buffer流数据)</p>\n</li>\n<li>\n<p>bodyParser.text(options): 解析文本数据</p>\n</li>\n<li>\n<p>bodyParser.urlencoded(options): 解析UTF-8的编码的数据。</p>\n<p>var bodyParser = require('body-parser');\n//创建 application/json 解析\napp.use(bodyParser.json())\n// 创建 application/x-www-form-urlencoded 解析\napp.use(bodyParser.urlencoded({extended: false}))</p>\n<p>app.post('/post', function (req, res) {\nvar params = req.body\nconsole.log(params)\n//{ params1: 'post_p1', params2: 'post_p2' }\n})</p>\n</li>\n</ol>\n<h5 id=\"bodyparser-json-options-返回一个仅解析json格式数据的中间件。\">bodyParser.json(options) :返回一个仅解析json格式数据的中间件。</h5>\n<p>option可选对象:</p>\n<blockquote>\n<ol>\n<li>inflate - 设置为true时，deflate压缩数据会被解压缩；设置为true时，deflate压缩数据会被拒绝。默认为true。</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li>limit - 设置请求的最大数据量。默认为'100kb'</li>\n<li>reviver - 传递给JSON.parse()方法的第二个参数，详见JSON.parse()</li>\n<li>strict - 设置为true时，仅会解析Array和Object两种格式；设置为false会解析所有JSON.parse支持的格式。默认为true</li>\n<li>type - 该选项用于设置为指定MIME类型的数据使用当前解析中间件。这个选项可以是一个函数或是字符串，当是字符串是会使用type-is来查找MIMI类型；当为函数是，中间件会通过fn(req)来获取实际值。默认为application/json。</li>\n<li>verify - 这个选项仅在verify(req, res, buf, encoding)时受支持</li>\n</ol>\n<h5 id=\"bodyparser-urlencoded-options-解析utf-8的编码的数据。\">bodyParser.urlencoded(options) 解析UTF-8的编码的数据。</h5>\n<p>返回一个处理urlencoded数据的中间件。\noption可选值：</p>\n<blockquote>\n<ol>\n<li>extended - 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li>inflate - 设置为true时，deflate压缩数据会被解压缩；设置为true时，deflate压缩数据会被拒绝。默认为true。</li>\n<li>limit - 设置请求的最大数据量。默认为'100kb'</li>\n<li>parameterLimit - 用于设置URL编码值的最大数据。默认为1000</li>\n<li>type - 该选项用于设置为指定MIME类型的数据使用当前解析中间件。这个选项可以是一个函数或是字符串，当是字符串是会使用type-is来查找MIMI类型；当为函数是，中间件会通过fn(req)来获取实际值。默认为application/octet-stream。</li>\n<li>verify - 这个选项仅在verify(req, res, buf, encoding)时受支持</li>\n</ol>\n<h4 id=\"req-query\">req.query</h4>\n<blockquote>\n<p>可以获得get请求参数</p>\n</blockquote>\n<hr>\n<h1 id=\"express-router用法\">Express.Router用法</h1>\n<p>从Express 4.0开始，路由器功能成了一个单独的组件Express.Router。它好像小型的express应用程序一样，有自己的use、get、param和route方法。</p>\n<h2 id=\"基本用法\">基本用法</h2>\n<p>首先，Express.Router是一个构造函数，调用后返回一个路由器实例。然后，使用该实例的HTTP动词方法，为不同的访问路径，指定回调函数；最后，挂载到某个路径。</p>\n<pre><code>var router = express.Router();\n\nrouter.get('/', function(req, res) {\n  res.send('首页');\n});\n\nrouter.get('/about', function(req, res) {\n  res.send('关于');\n});\n\napp.use('/', router);\n</code></pre>\n<p>上面代码先定义了两个访问路径，然后将它们挂载到根目录。如果最后一行改为app.use(‘/app’, router)，则相当于为/app和/app/about这两个路径，指定了回调函数。</p>\n<p>这种路由器可以自由挂载的做法，为程序带来了更大的灵活性，既可以定义多个路由器实例，也可以为将同一个路由器实例挂载到多个路径。</p>\n<h2 id=\"router中间件\">router中间件</h2>\n<p>use方法为router对象指定中间件，即在数据正式发给用户之前，对数据进行处理。下面就是一个中间件的例子。</p>\n<pre><code>router.use(function(req, res, next) {\n    console.log(req.method, req.url);\n    next();\n});\n</code></pre>\n<p>上面代码中，回调函数的next参数，表示接受其他中间件的调用。函数体中的next()，表示将数据传递给下一个中间件。</p>\n<p>注意，中间件的放置顺序很重要，等同于执行顺序。而且，中间件必须放在HTTP动词方法之前，否则不会执行。</p>\n<h2 id=\"对路径参数的处理\">对路径参数的处理</h2>\n<p>router对象的param方法用于路径参数的处理，可以</p>\n<pre><code>router.param('name', function(req, res, next, name) {\n    // 对name进行验证或其他处理……\n    console.log(name);\n    req.name = name;\n    next();\n});\n\nrouter.get('/hello/:name', function(req, res) {\n    res.send('hello ' + req.name + '!');\n});\n</code></pre>\n<p>上面代码中，get方法为访问路径指定了name参数，param方法则是对name参数进行处理。注意，param方法必须放在HTTP动词方法之前。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code></code></pre>\n<!--beforeend--></div><!--afterend--></div>\n",null]}